PROBLEM 2:
    // Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

    // 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

    // By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
    #include <iostream>
    using namespace std;
    typedef bool (*filterFunc)(int);

    bool getEven(int a) {
        return (a%2) == 0;
    }

    int calc_fibonacci(int limit, filterFunc filter) {
        int sum = 0;
        int lastTerm = 0;
        int thisTerm = 1;
        while (true) {
            int current = thisTerm + lastTerm;
            if (current > limit)
                break;

            if (filter(current))
                sum += current;
                
            lastTerm = thisTerm;
            thisTerm = current;
        }
        return sum;
    }

    int main() {
        int limit = 4e6;
        filterFunc filter = &getEven;
        int sum = calc_fibonacci(limit, filter);
        cout << "sum of all even terms of fibonacci to " << limit << " is " << sum << endl;
        return 0;
    }

PROBLEM 3
    // The prime factors of 13195 are 5, 7, 13 and 29.

    // What is the largest prime factor of the number 600851475143 ?

    #include <cmath>
    #include <vector>
    #include <iostream>
    #include <memory.h>
    using namespace std;

    vector<long long int> eratosthenes(long long int length) {
        //use this to memoize the first million or so prime numbers 
        bool *primes = new bool[length];
        memset(primes, true, length*sizeof(bool));

        vector<long long int> primeVec;

        for (long long int i = 2; i < sqrt(length); i++) {
            if (primes[i]) {
                for (long long int j = pow(i, 2); j <= length; j+=i) {
                    primes[j] = false;
                }
            }
        }

        for (long long int i = 0; i < length; i++) {
            if (primes[i]) {
                primeVec.push_back(i);
            }
        }

        return primeVec;
    }

    long long int largestPrimeFactor(long long int n, vector<long long int>& primes) {
        long long int largest = 1;
        while (n%2 == 0) {
            n = n / 2;
            largest = 2;
        }

        for (long long int i = 0; i < primes.size(); i++) {
            if (primes[i] > 2) {
                while((n%primes[i]) == 0) {
                    n = n/primes[i];
                    largest = primes[i];
                }
            } 
            // optimization to stop the loop when you reach the largest prime factor
            if (n < primes[i])
                break;    
        }

        if (largest == 1)
            largest = n;

        return largest;
    }

    int main() {
        long long int length = 1e4;
        long long int n = 600851475143;
        vector<long long int> primes = eratosthenes(length);
        long long int lpf = largestPrimeFactor(n, primes);
        cout << "The largest prime factor of " << n << " is " << lpf << endl;
    }

PROBLEM 4
    // A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.

    // Find the largest palindrome made from the product of two 3-digit numbers.
    #include <string>
    #include <iostream>

    using namespace std;

    bool isPalindrome(int n) {
        string num = to_string(n);
        int length = num.length();
        const char *number = num.c_str();
        int start = 0;
        int end = length-1;
        bool palindrome = true;
        for (int i = 0; i < length/2; i++) {
            if (number[start] != number[end]) {
                palindrome = false;
                break;  
            }       
            start++; 
            end--;
        }

        return palindrome;
    }

    int main() {
        int largestPalindrome = 0;
        int iterations = 0;
        int a_max = 0;
        int b_max = 0;
        for (int a = 999; a > 100; a--) {
            if (a_max*b_max > a*999)
                break;
            for (int b = 999; b > 100; b--) {
                iterations++;
                int current = a*b;
                if (isPalindrome(current)) {
                    if (current > largestPalindrome) {
                        a_max = a; b_max = b;
                        largestPalindrome = current;   
                    }
                    break;
                }
            }
        }

        cout << "The largest palindrome is formed by multiplying " << a_max << " and " << b_max << " and is " << largestPalindrome << endl;
        cout << "That took " << iterations << " iterations to solve" << endl;
    }
    
PROBLEM 5
    // 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

    // What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
    #include <iostream>
    using namespace std;



    int main() {
        long int lcm;
        long int iterations = 0;
        bool multiple = true;
        for (long int i = 2520; i <= 1e9; i += 2520) {

        for (int j = 11; j <=19; j++) {
            iterations++;
            if (i%j != 0) {
                multiple = false;
                break;
            }
            if (j == 19) {
                lcm = i; 
                goto done;
            }
        }
        } 
        done:
        cout << "The lcm of the numbers 1 - 20 is " << lcm << endl;
        cout << "That took " << iterations << " iterations" << endl;   
        return 0;
    }

REVERSE INTEGER

    #include <iostream>
    #include <memory.h>
    using namespace std;

    int reverseInteger(int n) {
        bool negative = false;
        if (n < 0) {
            negative = true;
            n *= -1;
        }
        string num = to_string(n);
        int length = num.length();
        const char *number = num.c_str();
        char *reverseNumber = new char[length-1];

        int j = 0;
        for (int i = length-1; i >=0; i--, j++) {
            reverseNumber[j] = number[i]; 
        }

        int reverse = atoi(reverseNumber);
        if(reverse%10 == (reverseNumber[length-1]-'0')) {
            if (negative)
                reverse *= -1;
            return reverse;
        } else {
            return 0;
        }
    }

    int main() {
        int numbers[] = {123, -123, 120, 0, 1234567899, 123456789};
        for (int number : numbers) {
            cout << reverseInteger(number) << endl;
        }
        return 0;
    }

REMOVE DUPLICATES
    #include <iostream>
    #include <vector>

    using namespace std;
    /*
        I'm proud of the logic on this one - modifications are made with O(1) memory requirements
    */
    void removeDuplicates(vector<int>& list) {
        int j = 0; 
        for (int i = 1; i < list.size(); i++) {
            if (list[i] == list[j]) {
                list[j] = list[i];
                while (list[i] == list[j]) {
                    i++;
                }
            }
            j++;
            list[j] = list[i];
        }
        list.resize(j+1);
    }

    int main() {
        int numbers[] = {0, 0, 0, 1, 2, 3, 4, 5, 5, 5, 6, 7, 8, 8, 9, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 15, 16, 17, 17, 18, 18, 19, 19, 20, 20, 20, 22};
        vector<int> list;
        for (int i : numbers)
            list.push_back(i);
        
        for(auto i : list) 
            cout << i << " ";
        cout << endl;

        removeDuplicates(list);

        for(auto i : list) 
            cout << i << " ";
        cout << endl;

        return 0;
    }